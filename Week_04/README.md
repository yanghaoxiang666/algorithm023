学习笔记
（1）深度优先遍历（deep first traverse）
定义：假设给定图G的初态是所有顶点均未曾访问过，在G中任选一顶点v为初始出发点(源点)，则深度优先遍历可定义如下：首先访问出发点v，并将其标记为已访问过；然后依次从v出发搜索v的每个邻接点w。若w未曾访问过，则以w为新的出发点继续进行深度优先遍历，直至图中所有和源点v有路径相通的顶点(亦称为从源点可达的顶点)均已被访问为止。若此时图中仍有未访问的顶点，则另选一个尚未访问的顶点作为新的源点重复上述过程，直至图中所有顶点均已被访问为止，这里定义使用的就是递归定义。
递归方式实现深度遍历的编码思想：所谓深度优先就是以纵向优先的方式遍历节点。我们从当前节点curr出发，如果当前节点被访问过，就返回，否则将该节点标记为访问过的节点，然后在递归访问当前节点的所有邻接节点。
栈和回溯方式实现深度遍历的编码思想：首先我们需要一个栈结构来存放需要被访问的节点，当然栈的第一个元素是我们传入的node节点，如果这个栈里面还有节点的话，拿出栈顶节点，访问该节点，然后将这个节点的所有未被访问的邻接节点压入栈中。
（2）广度优先遍历（broad first traverse）
定义：广度优先遍历是连通图的一种遍历策略，它的思想是从一个顶点V0开始，辐射状地优先遍历其周围较广的区域。也就是从V0出发，访问V0的各个未曾访问的邻接点W1，W2，…,Wk;然后,依次从W1,W2,…,Wk出发访问各自未被访问的邻接点；

队列实现广度优先遍历思想：所谓的广度优先指的是从当前节点curr出发，将该节点标记为已经访问过的节点，然后在依次访问curr的没有被访问的邻接节点，然后在依次访问邻接节点的邻接节点，直到所有的节点被访问。
（3）总结
使用递归和不使用递归的区别，假设到达目标需要begin->step1->step2->step3->....->stepN->target,其中stepN表示解决方案N，然后递归的方法是先拿到解决N，然后在退一步，拿到解决方案stepN-1,依次类推，直到最终拿到step1解决方案，而非递归方法是先拿到step1，然后在拿step2，最终拿到stepN。
贪心算法
一、基本概念
所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。
贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）
所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。
二、贪心算法的基本思路
建立数学模型来描述问题
把求解的问题分成若干个子问题
对每个子问题求解，得到子问题的局部最优解
把子问题的解局部最优解合成原来问题的一个解
三、该算法存在的问题
不能保证求得的最后解是最佳的
不能用来求最大值或最小值的问题
只能求满足某些约束条件的可行解的范围
四、贪心算法适用的问题
贪心策略适用的前提是：局部最优策略能导致产生全局最优解。
实际上，贪心算法适用的情况很少。一般对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可以做出判断。
五、贪心选择性质
所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，换句话说，当考虑做何种选择的时候，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。这是贪心算法可行的第一个基本要素。贪心算法以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。
当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用贪心算法求解的关键特征。
六、贪心算法的实现框架
从问题的某一初始解出发：
while (朝给定总目标前进一步)
{
利用可行的决策，求出可行解的一个解元素。
}
由所有解元素组合成问题的一个可行解；

